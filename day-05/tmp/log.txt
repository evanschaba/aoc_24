2024-12-06 00:57:10 - === STARTING SCRIPT EXECUTION ===
2024-12-06 00:57:10 - ===> COPYING ALGORITHM FROM PYTHON SCRIPT AND TRANSLATING TO RUST IN src/bin/part-2.rs <===
2024-12-06 00:57:10 - ===> COPYING ALGORITHM FROM PYTHON SCRIPT AND TRANSLATING TO RUST IN src/bin/part-2.rs <===
2024-12-06 00:57:10 - ===> DEVELOPING TESTS BASED ON ADVENT OF CODE CHALLENGE EXAMPLES <===
2024-12-06 00:57:10 - ===> DEVELOPING TESTS BASED ON ADVENT OF CODE CHALLENGE EXAMPLES <===
2024-12-06 00:57:10 - ===> WRITING RELEVANT AND PASSING UNIT TESTS <===
2024-12-06 00:57:10 - ===> WRITING RELEVANT AND PASSING UNIT TESTS <===
2024-12-06 00:57:10 - ===> ADDING PROPER DOCUMENTATION <===
2024-12-06 00:57:10 - ===> ADDING PROPER DOCUMENTATION <===
2024-12-06 00:57:10 - ===> OPTIMIZING USING SMALL, EFFICIENT DATA STRUCTURES <===
2024-12-06 00:57:10 - ===> OPTIMIZING USING SMALL, EFFICIENT DATA STRUCTURES <===
2024-12-06 00:57:10 - ===> IMPROVING LOGGING AND TRACING, INCLUDING TESTS <===
2024-12-06 00:57:10 - ===> IMPROVING LOGGING AND TRACING, INCLUDING TESTS <===
2024-12-06 00:57:10 - ===> LEAVING MAIN FUNCTION FILE INPUT PARSING AS IS <===
2024-12-06 00:57:10 - ===> LEAVING MAIN FUNCTION FILE INPUT PARSING AS IS <===
2024-12-06 00:57:10 - ===> FOCUS ON THE the rust code only, !! leave THE SCRIPTS ALONE !! <===
2024-12-06 00:57:10 - ===> FOCUS ON THE the rust code only, !! leave THE SCRIPTS ALONE !! <===
2024-12-06 00:57:10 - ===> FIXING ALL FAILING TESTS SINCE THEY ARE BROKEN IN part-2.rs <===
2024-12-06 00:57:10 - ===> FIXING ALL FAILING TESTS SINCE THEY ARE BROKEN IN part-2.rs <===
2024-12-06 00:57:10 - 

2024-12-06 00:57:10 - 

2024-12-06 00:57:10 - ===> Challenge Documentation Preview <===
2024-12-06 00:57:10 - ===> Challenge Documentation Preview <===
#### --- Day 5: Print Queue (Part II) ---


While the Elves get to work printing the correctly-ordered updates, you have a little time to fix the rest of them.

For each of the *incorrectly-ordered updates*, use the page ordering rules to put the page numbers in the right order. For the above example, here are the three incorrectly-ordered updates and their correct orderings:

`75`,`97`,`47`,`61`,`53` becomes `97`,`75`,**`47`**,`61`,`53`.
`61`,`13`,`29` becomes `61`,**`29`**,`13`.
`97`,`13`,`75`,`29`,`47` becomes `97`,`75`,**`47`**,`29`,`13`.
After taking only the incorrectly-ordered updates and ordering them correctly, their middle page numbers are `47, 29, and 47. Adding these together produces **`123`**.

Find the updates which are not in the correct order. *What do you get if you add up the middle page numbers after correctly ordering just those updates?*

To begin, [*get your puzzle input*](input_queue_2.txt).

Answer: _____2024-12-06 00:57:10 - 
===> Python Algorithm (2_queue.py) <===
2024-12-06 00:57:10 - 
===> Python Algorithm (2_queue.py) <===
from collections import defaultdict

with open("./docs/input_queue_2.txt") as fin:
    raw_rules, updates = fin.read().strip().split("\n\n")
    rules = []
    for line in raw_rules.split("\n"):
        a, b = line.split("|")
        rules.append((int(a), int(b)))
    updates = [list(map(int, line.split(","))) for line in updates.split("\n")]


def follows_rules(update):
    idx = {}
    for i, num in enumerate(update):
        idx[num] = i
    
    for a, b in rules:
        if a in idx and b in idx and not idx[a] < idx[b]:
            return False, 0
        
    return True, update[len(update) // 2]


# Topological sort, I guess
def sort_correctly(update):
    my_rules = []
    for a, b in rules:
        if not (a in update and b in update):
            continue
        my_rules.append((a, b))

    indeg = defaultdict(int)
    for a, b in my_rules:
        indeg[b] += 1
    
    ans = []
    while len(ans) < len(update):
        for x in update:
            if x in ans:
                continue
            if indeg[x] <= 0:
                ans.append(x)
                for a, b in my_rules:
                    if a == x:
                        indeg[b] -= 1
    
    return ans


ans = 0

for update in updates:
    if follows_rules(update)[0]:
        continue

    seq = sort_correctly(update)
    ans += seq[len(seq) // 2]

print(ans)2024-12-06 00:57:10 - 
===> Rust Source Code (src/bin/part-2.rs) Preview <===
2024-12-06 00:57:10 - 
===> Rust Source Code (src/bin/part-2.rs) Preview <===
use std::collections::{HashSet, HashMap};
use std::env;
use std::fs;
use std::process;

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() != 2 {
        eprintln!("Usage: cargo run --bin part-2 <input-file>");
        process::exit(1);
    }
    let input_path = &args[1];
    let content = fs::read_to_string(input_path).expect("Failed to read input file");
    let (raw_rules, updates_section) = content
        .trim()
        .split_once("\n\n")
        .expect("Invalid input format: Input should contain rules and updates separated by a double newline.");

    let rules: Vec<(i32, i32)> = raw_rules
        .lines()
        .map(|line| {
            let parts: Vec<i32> = line
                .split('|')
                .map(|x| x.trim().parse().expect("Invalid number in rules"))
                .collect();
            if parts.len() != 2 {
                panic!(
                    "Invalid rule format, expected two numbers separated by '|': {}",
                    line
                );
            }
            (parts[0], parts[1])
        })
        .collect();

    let updates: Vec<Vec<i32>> = updates_section
        .lines()
        .map(|line| {
            line.split(',')
                .map(|x| x.trim().parse().expect("Invalid number in update"))
                .collect()
        })
        .collect();

    let mut ans = 0;

    for update in &updates {
        if follows_rules(update, &rules).0 {
            continue;
        }
        let sorted_update = sort_correctly(update, &rules);
        ans += sorted_update[sorted_update.len() / 2];
    }

    println!("Answer: {}", ans);
}

fn follows_rules(update: &[i32], rules: &[(i32, i32)]) -> (bool, i32) {
    let idx_set: HashSet<i32> = update.iter().cloned().collect();

    for (a, b) in rules {
        if idx_set.contains(a) && idx_set.contains(b) {
            if let (Some(pos_a), Some(pos_b)) = (
                update.iter().position(|&x| x == *a),
                update.iter().position(|&x| x == *b),
            ) {
                if pos_a >= pos_b {
                    return (false, 0);
                }
            }
        }
    }

    let mid = update[update.len() / 2];
    (true, mid)
}

fn sort_correctly(update: &[i32], rules: &[(i32, i32)]) -> Vec<i32> {
    let mut dependency_count = HashMap::new();

    // Count dependencies for each element
    for (_a, b) in rules.iter().filter(|&&(a, b)| update.contains(&a) && update.contains(&b)) {
        *dependency_count.entry(b).or_insert(0) += 1;
    }

    let mut sorted = Vec::new();
    while sorted.len() < update.len() {
        for &item in update {
            if !sorted.contains(&item) && dependency_count.get(&item).unwrap_or(&0) == &0 {
                sorted.push(item);
                // Decrease the dependency count for items that depend on the current item
                for (a, b) in rules {
                    if *a == item {
                        if let Some(count) = dependency_count.get_mut(&b) {
                            *count -= 1;
                        }
                    }
                }
            }
        }
    }

    sorted
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_part_2_example() {
        let rules = vec![
            (47, 53),
            (97, 13),
            (97, 61),
            (97, 47),
            (75, 29),
            (61, 13),
            (75, 53),
            (29, 13),
            (97, 29),
            (53, 29),
            (61, 53),
            (97, 53),
            (61, 29),
            (47, 13),
            (75, 47),
            (97, 75),
            (47, 61),
            (75, 61),
            (47, 29),
            (75, 13),
            (53, 13),
        ];

        let updates = vec![
            vec![75, 97, 47, 61, 53],
            vec![61, 13, 29],
            vec![97, 13, 75, 29, 47],
        ];

        let mut ans = 0;
        for update in &updates {
            if follows_rules(update, &rules).0 {
                continue;
            }
            let sorted_update = sort_correctly(update, &rules);
            ans += sorted_update[sorted_update.len() / 2];
        }

        assert_eq!(ans, 123);
    }
}
2024-12-06 00:57:10 - 
===> Running cargo test for part-1... <===
2024-12-06 00:57:10 - 
===> Running cargo test for part-1... <===
   Compiling day-05 v0.1.0 (/Users/deltd3v/Desktop/workspaces/aoc_24/day-05)
   Compiling day-05 v0.1.0 (/Users/deltd3v/Desktop/workspaces/aoc_24/day-05)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.31s
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running unittests src/bin/part-2.rs (target/debug/deps/part_2-65311ec0ee3aab95)
     Running unittests src/bin/part-2.rs (target/debug/deps/part_2-65311ec0ee3aab95)

running 1 test

running 1 test
test tests::test_part_2_example ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered outtest tests::test_part_2_example ... ok
; finished in 0.00s


test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

2024-12-06 00:57:10 - 
Copying the first 5000 lines of the log file to clipboard...
2024-12-06 00:57:10 - === SCRIPT EXECUTION COMPLETED ===
